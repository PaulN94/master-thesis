{
    "variations": [
        {
            "id": "1.2.1.1",
            "question_variation": "What would happen if the maximum allowed weight is changed to 5?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)), GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nweights = [5, 8, 3, 2]\nW = 5\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "W = 5"
        },
        {
            "id": "1.2.1.2",
            "question_variation": "What would happen if the maximum allowed weight is changed to 6?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)), GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nweights = [5, 8, 3, 2]\nW = 6\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "W = 6"
        },
        {
            "id": "1.2.1.3",
            "question_variation": "What would happen if the maximum allowed weight is changed to 6?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)), GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nweights = [5, 8, 3, 2]\nW = 6\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "W = 6"
        },
        {
            "id": "1.2.2.1",
            "question_variation": "What would be the effect on the selection if the weight of the item with the index 1 was changed to 6?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)), GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nweights = [5, 8, 3, 2]\nweights[1] = 6\nW = 10\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "weights[1] = 6"
        },
        {
            "id": "1.2.2.2",
            "question_variation": "What would be the effect on the selection if the weight of the item with the index 1 was changed to 7?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)), GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nweights = [5, 8, 3, 2]\nweights[1] = 7\nW = 10\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "weights[1] = 7"
        },
        {
            "id": "1.2.2.3",
            "question_variation": "What would be the effect on the selection if the weight of the item with the index 1 was changed to 7?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)), GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nweights = [5, 8, 3, 2]\nweights[1] = 7\nW = 10\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "weights[1] = 7"
        },
        {
            "id": "1.2.3.1",
            "question_variation": "If the value of the item with the index 2 is updated to 18, how would the optimal selection be influenced?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)), GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nvalues[2] = 18\nweights = [5, 8, 3, 2]\nW = 10\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "values[2] = 18"
        },
        {
            "id": "1.2.3.2",
            "question_variation": "If the value of the item with the index 3 is updated to 13, how would the optimal selection be influenced?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)), GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nvalues[3] = 13\nweights = [5, 8, 3, 2]\nW = 10\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "values[3] = 13"
        },
        {
            "id": "1.2.3.3",
            "question_variation": "If the value of the item with the index 2 is updated to 29, how would the optimal selection be influenced?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)), GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nvalues[2] = 29\nweights = [5, 8, 3, 2]\nW = 10\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "values[2] = 29"
        },
        {
            "id": "1.2.4.1",
            "question_variation": "How would you modify the objective function of the given knapsack problem to incorporate an L1 regularization, aiming to reduce the number of selected items, by adding a penalty term of 7.896383916537406 for each selected item?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)) - 7.896383916537406 * sum(x[i] for i in range(n)), GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nweights = [5, 8, 3, 2]\nW = 10\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "m.setObjective(sum(values[i] * x[i] for i in range(n)) - 7.896383916537406 * sum(x[i] for i in range(n)), GRB.MAXIMIZE)"
        },
        {
            "id": "1.2.4.2",
            "question_variation": "How would you modify the objective function of the given knapsack problem to incorporate an L1 regularization, aiming to reduce the number of selected items, by adding a penalty term of 1.6902718703661637 for each selected item?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)) - 1.6902718703661637 * sum(x[i] for i in range(n)), GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nweights = [5, 8, 3, 2]\nW = 10\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "m.setObjective(sum(values[i] * x[i] for i in range(n)) - 1.6902718703661637 * sum(x[i] for i in range(n)), GRB.MAXIMIZE)"
        },
        {
            "id": "1.2.4.3",
            "question_variation": "How would you modify the objective function of the given knapsack problem to incorporate an L1 regularization, aiming to reduce the number of selected items, by adding a penalty term of 4.44132330032333 for each selected item?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)) - 4.44132330032333 * sum(x[i] for i in range(n)), GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nweights = [5, 8, 3, 2]\nW = 10\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "m.setObjective(sum(values[i] * x[i] for i in range(n)) - 4.44132330032333 * sum(x[i] for i in range(n)), GRB.MAXIMIZE)"
        },
        {
            "id": "1.2.5.1",
            "question_variation": "Imagine there's a synergy between the items with the idices 3 and 1 such that if both are selected, an additional value of 7.9503561620695775 is added to the objective. How can you model this effect in the objective function?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)) + 7.9503561620695775 * x[3] * x[1], GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nweights = [5, 8, 3, 2]\nW = 10\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "m.setObjective(sum(values[i] * x[i] for i in range(n)) + 7.9503561620695775 * x[3] * x[1], GRB.MAXIMIZE)"
        },
        {
            "id": "1.2.5.2",
            "question_variation": "Imagine there's a synergy between the items with the idices 2 and 1 such that if both are selected, an additional value of 8.19600440098655 is added to the objective. How can you model this effect in the objective function?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)) + 8.19600440098655 * x[2] * x[1], GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nweights = [5, 8, 3, 2]\nW = 10\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "m.setObjective(sum(values[i] * x[i] for i in range(n)) + 8.19600440098655 * x[2] * x[1], GRB.MAXIMIZE)"
        },
        {
            "id": "1.2.5.3",
            "question_variation": "Imagine there's a synergy between the items with the idices 2 and 2 such that if both are selected, an additional value of 1.3454953165209087 is added to the objective. How can you model this effect in the objective function?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)) + 1.3454953165209087 * x[2] * x[2], GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nweights = [5, 8, 3, 2]\nW = 10\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "m.setObjective(sum(values[i] * x[i] for i in range(n)) + 1.3454953165209087 * x[2] * x[2], GRB.MAXIMIZE)"
        },
        {
            "id": "1.2.6.1",
            "question_variation": "Imagine a scenario where a penalty of 13.321092975096068 units is applied for each additional item after the item with the index 1. How would you modify the objective function to account for this?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)) - 13.321092975096068 * sum(x[i] for i in range(2, n)), GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nweights = [5, 8, 3, 2]\nW = 10\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "m.setObjective(sum(values[i] * x[i] for i in range(n)) - 13.321092975096068 * sum(x[i] for i in range(2, n)), GRB.MAXIMIZE)"
        },
        {
            "id": "1.2.6.2",
            "question_variation": "Imagine a scenario where a penalty of 6.684316429288231 units is applied for each additional item after the item with the index 1. How would you modify the objective function to account for this?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)) - 6.684316429288231 * sum(x[i] for i in range(2, n)), GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nweights = [5, 8, 3, 2]\nW = 10\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "m.setObjective(sum(values[i] * x[i] for i in range(n)) - 6.684316429288231 * sum(x[i] for i in range(2, n)), GRB.MAXIMIZE)"
        },
        {
            "id": "1.2.6.3",
            "question_variation": "Imagine a scenario where a penalty of 6.819845408440081 units is applied for each additional item after the item with the index 1. How would you modify the objective function to account for this?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)) - 6.819845408440081 * sum(x[i] for i in range(2, n)), GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nweights = [5, 8, 3, 2]\nW = 10\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "m.setObjective(sum(values[i] * x[i] for i in range(n)) - 6.819845408440081 * sum(x[i] for i in range(2, n)), GRB.MAXIMIZE)"
        },
        {
            "id": "1.2.7.1",
            "question_variation": "How does the model change if we introduce a lower bound constraint such that at least 2 items must be selected?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)), GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Minimum items constraint\n    m.addConstr(sum(x[i] for i in range(n)) >= 2, \"min_items_constraint\")\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nweights = [5, 8, 3, 2]\nW = 10\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "m.addConstr(sum(x[i] for i in range(n)) >= 2)"
        },
        {
            "id": "1.2.7.2",
            "question_variation": "How does the model change if we introduce a lower bound constraint such that at least 3 items must be selected?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)), GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Minimum items constraint\n    m.addConstr(sum(x[i] for i in range(n)) >= 3, \"min_items_constraint\")\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nweights = [5, 8, 3, 2]\nW = 10\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "m.addConstr(sum(x[i] for i in range(n)) >= 3)"
        },
        {
            "id": "1.2.7.3",
            "question_variation": "How does the model change if we introduce a lower bound constraint such that at least 3 items must be selected?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)), GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Minimum items constraint\n    m.addConstr(sum(x[i] for i in range(n)) >= 3, \"min_items_constraint\")\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nweights = [5, 8, 3, 2]\nW = 10\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "m.addConstr(sum(x[i] for i in range(n)) >= 3)"
        },
        {
            "id": "1.2.8.1",
            "question_variation": "Given that the item with the index 2 is mandatory in the knapsack, how would the remaining items be optimally selected?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)), GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Mandatory item constraint\n    m.addConstr(x[2] == 1, \"mandatory_item_constraint\")\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nweights = [5, 8, 3, 2]\nW = 10\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "m.addConstr(x[2] == 1"
        },
        {
            "id": "1.2.8.2",
            "question_variation": "Given that the item with the index 2 is mandatory in the knapsack, how would the remaining items be optimally selected?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)), GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Mandatory item constraint\n    m.addConstr(x[2] == 1, \"mandatory_item_constraint\")\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nweights = [5, 8, 3, 2]\nW = 10\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "m.addConstr(x[2] == 1"
        },
        {
            "id": "1.2.8.3",
            "question_variation": "Given that the item with the index 1 is mandatory in the knapsack, how would the remaining items be optimally selected?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)), GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Mandatory item constraint\n    m.addConstr(x[1] == 1, \"mandatory_item_constraint\")\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nweights = [5, 8, 3, 2]\nW = 10\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "m.addConstr(x[1] == 1"
        },
        {
            "id": "1.2.9.1",
            "question_variation": "If you were to restrict the number of items in the knapsack to a maximum of 3, how would that influence the solution?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)), GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Maximum items constraint\n    m.addConstr(sum(x[i] for i in range(n)) <= 3, \"max_items_constraint\")\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nweights = [5, 8, 3, 2]\nW = 10\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "m.addConstr(sum(x[i] for i in range(n)) <= 3)"
        },
        {
            "id": "1.2.9.2",
            "question_variation": "If you were to restrict the number of items in the knapsack to a maximum of 2, how would that influence the solution?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)), GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Maximum items constraint\n    m.addConstr(sum(x[i] for i in range(n)) <= 2, \"max_items_constraint\")\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nweights = [5, 8, 3, 2]\nW = 10\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "m.addConstr(sum(x[i] for i in range(n)) <= 2)"
        },
        {
            "id": "1.2.9.3",
            "question_variation": "If you were to restrict the number of items in the knapsack to a maximum of 1, how would that influence the solution?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)), GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Maximum items constraint\n    m.addConstr(sum(x[i] for i in range(n)) <= 1, \"max_items_constraint\")\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nweights = [5, 8, 3, 2]\nW = 10\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "m.addConstr(sum(x[i] for i in range(n)) <= 1)"
        },
        {
            "id": "1.2.10.1",
            "question_variation": "If there's a requirement that either item with index 0 or item with index 3 must be included in the knapsack but not both, how would you adjust the model to ensure this condition is met?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)), GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Either or constraint\n    m.addConstr(x[0] + x[3] <= 1)\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nweights = [5, 8, 3, 2]\nW = 10\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "m.addConstr(x[0] + x[3] <= 1)"
        },
        {
            "id": "1.2.10.2",
            "question_variation": "If there's a requirement that either item with index 1 or item with index 3 must be included in the knapsack but not both, how would you adjust the model to ensure this condition is met?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)), GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Either or constraint\n    m.addConstr(x[1] + x[3] <= 1)\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nweights = [5, 8, 3, 2]\nW = 10\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "m.addConstr(x[1] + x[3] <= 1)"
        },
        {
            "id": "1.2.10.3",
            "question_variation": "If there's a requirement that either item with index 2 or item with index 0 must be included in the knapsack but not both, how would you adjust the model to ensure this condition is met?",
            "answer_variation": "from gurobipy import Model, GRB\n\n\ndef knapsack_gurobi(values, weights, W):\n    # Number of items\n    n = len(values)\n\n    # Create a new Gurobi model\n    m = Model(\"knapsack_transform\")\n\n    # Decision variables\n    x = m.addVars(n, vtype=GRB.BINARY, name=\"x\")\n\n    # Objective function\n    m.setObjective(sum(values[i] * x[i] for i in range(n)), GRB.MAXIMIZE)\n\n    # Weight constraint\n    m.addConstr(sum(weights[i] * x[i] for i in range(n)) <= W, \"weight_constraint\")\n\n    # Either or constraint\n    m.addConstr(x[2] + x[0] <= 1)\n\n    # Solve the model\n    m.optimize()\n\n    # Extract the solution\n    selected_items = [i for i in range(n) if x[i].X > 0.5]\n\n    return selected_items\n\n\n# Data\nvalues = [20, 30, 50, 10]\nweights = [5, 8, 3, 2]\nW = 10\nselected_items = knapsack_gurobi(values, weights, W)\nprint(selected_items)\n            ",
            "answer_section": "m.addConstr(x[2] + x[0] <= 1)"
        }
    ]
}